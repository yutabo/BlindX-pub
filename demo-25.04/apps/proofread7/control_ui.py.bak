import gradio as gr
import subprocess
import os
import signal
from pathlib import Path
import threading

# ãƒ—ãƒ­ã‚»ã‚¹æƒ…å ±ä¿æŒç”¨
current_process = None
resume_flag = False
input_file_cache = []

OUTPUT_DIR = "output_html"
HOTWORDS_FILE = "hotwords.txt"
MAIN_SCRIPT = "main_cui.py"

# ãƒ›ãƒƒãƒˆãƒ¯ãƒ¼ãƒ‰ã‚’ hotwords.txt ã«ä¿å­˜
def save_hotwords(global_text, local_text):
    all_lines = global_text.strip().splitlines() + local_text.strip().splitlines()
    with open(HOTWORDS_FILE, "w", encoding="utf-8") as f:
        f.write("\n".join(line.strip() for line in all_lines if line.strip()) + "\n")

# ãƒ¡ã‚¤ãƒ³å‡¦ç†å®Ÿè¡Œï¼ˆå†å¸°ã§ã¯ãªãã‚¹ãƒ¬ãƒƒãƒ‰ï¼‰
def run_processing(files, max_chars, num_beams, log_box):
    global current_process, resume_flag, input_file_cache

    Path(OUTPUT_DIR).mkdir(exist_ok=True)

    def process():
        nonlocal files
        log_messages = []

        for file in files:
            input_path = Path(file.name)
            output_path = Path(OUTPUT_DIR) / (input_path.name + ".html")

            if resume_flag and output_path.exists():
                log_messages.append(f"â© Skip: {output_path.name}")
                continue

            cmd = [
                "python3", MAIN_SCRIPT,
                "--input", str(input_path),
                "--hotfile", HOTWORDS_FILE,
                "--output", str(output_path),
                "--max_chars", str(max_chars),
                "--num_beams", str(num_beams)
            ]

            log_messages.append(f"[{input_path.name}] å®Ÿè¡Œä¸­: {' '.join(cmd)}")

            try:
                current_process = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
                stdout, stderr = current_process.communicate()

                if current_process.returncode == 0:
                    log_messages.append(f"âœ… å®Œäº†: {output_path.name}")
                else:
                    log_messages.append(f"âŒ ã‚¨ãƒ©ãƒ¼: {stderr.decode(errors='ignore')}")

            except Exception as e:
                log_messages.append(f"âŒ å®Ÿè¡Œå¤±æ•—: {str(e)}")

            log_box.update("\n".join(log_messages))

        log_messages.append("ğŸ‰ å…¨å‡¦ç†å®Œäº†")
        log_box.update("\n".join(log_messages))
        current_process = None

    thread = threading.Thread(target=process)
    thread.start()

# STOPå‡¦ç†
def stop_process(log_box):
    global current_process
    if current_process and current_process.poll() is None:
        current_process.terminate()
        log_box.update("â¹ å‡¦ç†ã‚’ä¸­æ–­ã—ã¾ã—ãŸ")
        return
    log_box.update("âš  åœæ­¢ä¸­ã®ãƒ—ãƒ­ã‚»ã‚¹ã¯ã‚ã‚Šã¾ã›ã‚“")

# RESUMEå‡¦ç†
def resume_processing(global_text, local_text, files, max_chars, num_beams, log_box):
    global resume_flag
    save_hotwords(global_text, local_text)
    resume_flag = True
    run_processing(files, max_chars, num_beams, log_box)

# Gradio UI
with gr.Blocks() as app:
    gr.Markdown("## ğŸ“ æ ¡æ­£ãƒ„ãƒ¼ãƒ« UIï¼ˆSTOP / RESUME å¯¾å¿œï¼‰")

    with gr.Row():
        global_hotwords = gr.Textbox(label="Global Hotwords", lines=20)
        local_hotwords = gr.Textbox(label="Local Hotwords", lines=20)
        input_files = gr.File(label="INPUTãƒ•ã‚¡ã‚¤ãƒ«", file_types=[".txt", ".h"], file_count="multiple")
        output_links = gr.HTML(label="å‡ºåŠ›ãƒªãƒ³ã‚¯")

    with gr.Row():
        max_chars = gr.Slider(0, 256, step=8, label="è©°ã‚è¾¼ã¿æ–‡å­—æ•°", value=128)
        num_beams = gr.Slider(1, 8, step=1, label="å€™è£œæ•°ï¼ˆbeamsï¼‰", value=4)

    with gr.Row():
        start_btn = gr.Button("â–¶ START")
        stop_btn = gr.Button("â¹ STOP")
        resume_btn = gr.Button("âµ RESUME")

    log_box = gr.Textbox(label="ãƒ­ã‚°", lines=15, interactive=False)

    start_btn.click(
        fn=lambda global_text, local_text, files, chars, beams, log: (
            save_hotwords(global_text, local_text),
            run_processing(files, chars, beams, log)
        ),
        inputs=[global_hotwords, local_hotwords, input_files, max_chars, num_beams, log_box],
        outputs=[]
    )

    stop_btn.click(fn=stop_process, inputs=[log_box], outputs=[])
    resume_btn.click(
        fn=resume_processing,
        inputs=[global_hotwords, local_hotwords, input_files, max_chars, num_beams, log_box],
        outputs=[]
    )

app.launch()